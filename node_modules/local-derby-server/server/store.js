// Generated by CoffeeScript 1.10.0
(function() {
  var _, coffeeify, conf, derby, liveDbMongo, livedb, shareAccess, yamlify,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  _ = require('lodash');

  conf = require('nconf');

  liveDbMongo = require('livedb-mongo');

  livedb = require('livedb');

  coffeeify = require('coffeeify');

  yamlify = require('yamlify');

  derby = require('derby');

  shareAccess = require('share-access');

  module.exports = function(options) {
    var backend, mongo, mongoUrl, redis, redisClient, redisDriver, redisObserver, store;
    if (options.accessControl != null) {
      derby.use(shareAccess, {
        dontUseOldDocs: true
      });
    }
    if (options.schema != null) {
      derby.use(require('racer-schema'), options.schema);
    }
    options.ee.emit('storeUse', derby);
    mongoUrl = conf.get('MONGO_URL');
    if (/auto_reconnect/.test(mongoUrl)) {
      if (/\?/.test(mongoUrl)) {
        mongoUrl += '&';
      } else {
        mongoUrl += '?';
      }
      mongoUrl += 'auto_reconnect';
    }
    mongo = liveDbMongo(mongoUrl, {
      safe: true,
      allowAllQueries: true
    });
    store = conf.get('REDIS_URL') && conf.get('BUNDLE_MODE') !== 'save' ? (redis = require('redis-url'), redisClient = redis.connect(), redisObserver = redis.connect(), redisClient.on('connect', function() {
      return redisClient.flushdb(function(err, didSucceed) {
        if (err) {
          return console.log('Redis flushdb err:', err);
        } else {
          return console.log('Redis flushdb success:', didSucceed);
        }
      });
    }), redisDriver = livedb.redisDriver(mongo, redisClient, redisObserver), backend = livedb.client({
      driver: redisDriver,
      db: mongo
    }), derby.createStore({
      backend: backend
    })) : derby.createStore({
      db: mongo
    });
    if (typeof options.accessControl === "function") {
      options.accessControl(shareAccess, store);
    }
    if (options.hooks != null) {
      require('derby-hook')(store);
    }
    if (typeof options.hooks === "function") {
      options.hooks(store);
    }
    options.ee.emit('store', store);
    store.on('bundle', function(browserify) {
      var pack;
      options.ee.emit('bundle', browserify);
      browserify.transform({
        global: true
      }, coffeeify);
      browserify.transform(yamlify);
      pack = browserify.pack;
      return browserify.pack = function(opts) {
        var detectTransform;
        detectTransform = opts.globalTransform.shift();
        opts.globalTransform.push(detectTransform);
        return pack.apply(this, arguments);
      };
    });
    store.ADMINS = [];
    (function(store) {
      var adminIds, model, superadmins;
      model = store.createModel();
      adminIds = model.at('service.adminIds');
      superadmins = model.query('auths', {
        'email': {
          $in: conf.get('ADMINS')
        }
      });
      return model.fetch(adminIds, superadmins, function() {
        var i, len, ref, ref1, superadmin, theAdminIds;
        theAdminIds = adminIds.get() || [];
        ref = superadmins.get();
        for (i = 0, len = ref.length; i < len; i++) {
          superadmin = ref[i];
          if (ref1 = superadmin.id, indexOf.call(theAdminIds, ref1) < 0) {
            adminIds.push(superadmin.id);
          }
        }
        store.ADMINS = adminIds.get() || [];
        return console.log('Admins: ' + store.ADMINS.length);
      });
    })(store);
    return store;
  };

}).call(this);
