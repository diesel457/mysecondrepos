conf = require 'nconf'
stripe = require 'stripe'
_ = require 'lodash'

module.exports = class StripeController

  constructor: (@options) ->
    @stripe = stripe @options.keys.secret

  pay: (req, res, next) ->
    { token, price, name, description, type, meta } = req.body

    @_validatePayment req, price, type, meta, (err) =>
      return next err if err

      description = "[#{name}] #{description}"

      model = req.getModel()
      auth = model.at 'auths.' + req.session.userId
      auth.fetch (err) =>
        return next err if err
        return next 'Not logged in' unless auth.get()

        email = auth.get('emails.0') || auth.get('email') || auth.get('local.email')

        # Charge the card
        @stripe.charges.create
          amount: Math.round(price * 100)
          currency: 'usd'
          card: token.id
          description: description
          receipt_email: email
          metadata: _.merge {}, meta,
            userId: req.session.userId
            type: type
        , (err, data) =>
          return next err if err

          # Add payment to our log
          model.add @options.paymentsCollection, _.merge {}, meta,
            userId: req.session.userId
            type: type
            stripeId: data.id
            price: price
            description: description
            createdAt: +new Date()

          if @options.hooks[type]?
            @options.hooks[type] req, auth, meta, ->
              res.json true
          else
            res.json true

  _validatePayment: (req, price, type, meta, cb) ->
    return cb 'No price' unless _.isNumber(price) and price > 0
    return cb() unless type

    # Find validation price or function
    validation = @options.validation[type]
    return cb() unless validation?

    # Validate
    if _.isFunction(validation)
      return validation.call this, req, price, meta, cb
    else if _.isNumber(validation)
      return cb 'Client price is wrong' unless price is validation

    cb()